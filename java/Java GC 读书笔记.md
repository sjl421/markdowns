# Java GC 读书笔记

1. 在代码调试的时候打印系统的GC日志

```wiki
-XX:+PrintGC 输出GC日志
-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log 日志文件的输出路径
```

```wiki
-XX:+PrintGCDetails -Xloggc:../logs/gc.log -XX:+PrintGCTimeStamps  
```

### 常用的垃圾回收算法

1. 给每一个对对象都增加一个引用计数器，每当有一个地方引用这个对象时，引用计数器就加1，当应用失效时，计数器就减1；

### java 虚拟机中使用的垃圾回收算法

可发性分析：

通过一系列的成为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，此时这些对象就是可以被回收的对象对了；

Java虚拟机可作为GC Roots的对象：

* 虚拟机栈中应用的对象；
* 方法区中静态属性引用的对象；
* 方法区中常量引用的对象；
* 本地方法栈中引用的对象；

### 引用的四种分类

1. 强应用

> 强应用是指在程序代码中普遍存在的那种类似于Object obj = new Object()这种引用，只要强引用存在，垃圾回收器就永远不会回收掉被引用的对象；

2. 软引用

> 软引用用来描述一些还有用但是并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出的异常；

3. 弱引用

> 弱引用也是用来描述非必须对象的，被弱引用关联的对象只能生存到下一次垃圾回收发生之前，当垃圾回收时，无论当前内存是否足够，都会回收掉被弱引用关联的对象；

4. 虚引用

> 也称为幽灵引用和幻影引用，一个引用是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过徐引用来取得一个对象的实例。为一个对象设置虚引用的唯一目的就是能在这个对象被回收时收到一个系统通知；

### 生存还是死亡

1. 在虚拟机分析一个对象是不可大的状态时，也并不是说这个对象是“非死不可”的，这时候他暂时处于缓刑期；
2. 系统真的要回收一个对象一般要经历两个标记过程：如果一个对象在进行可达性分析后没有与GC roots相连接的引用链，那他们将会被第一次标记并且运行一次筛选，筛选的条件是此对象是否有必要要执行finalize方法。如果一个对象没有被finalize方法覆盖或者finalize方法已经被虚拟机调用过，那么虚拟机就会分析得出此对象没有必要在执行finalize方法了
3. 对于虚拟机分析得出的需要执行finalize()方法的对象，会将此对象放入一个叫F-queue的队列中，并在稍后虚拟机会创建一个低优先级的finalize线程去执行这个finalize方法(但并不承诺会等待他运行完成)
4. finalize()方法是该对象逃离被回收的最后一次机会；随后GC会对F-queue中的对象爱你进行第二次小规模标记，如果对象要在finalize()中成功拯救自己，只要重新与某个引用链接上(如何链接？)
5. 如果第二次标记后该对象还没偶逃脱，那么这个对象基本上就真的被回收了；

### 方法区的回收

永久带的垃圾回收主要是两部分：废弃常量和无用的类

废弃的常量：比如说字符串常量；

判断一个类是不是无用的类的标准：

* 该类所有的实例都已经被回收，也就是说java堆中不存在该类的任何实例；
* 加载该类的ClassLoader已经被回收了；
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；



## 垃圾回收算法

### 标记-清除算法（mark-sweep）

两个阶段：标记-清除

* 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；

存在的问题：

1. 效率问题：标记和清除两个过程的效率都不高；
2. 空间问题：标记清除之后会产生大量的不连续的内存碎片；

### 复制算法：

首先内存复制算法是将内存分成大小相等的两块，每次只使用其中的一块，当这一块的内存用我那里额，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉，每次清理是对整个半区的清理。

这样，每次清理是对真分配内存时就不会出现碎片化的问题了；

使用使用的算法是：

内存被分为三部分：一块比较大的Eden区和两块比较小的Survivor区（8:1:1）；每次使用的是Eden区和Survivor区（利用了90%）；

当回收时，将Eden和Survivor区中还存活的对象一次性的复制到另一块Survivor区中，最后清理掉Eden和刚刚使用过的Survivor区；

同时，为了保证当Survivor空间不够使用的时候，会将Survivor中的对象放入老年代中。

### 标记整理算法

这种算法一般是老年代中采用的算法，和标记清除算法很相似，但是后续并不是直接对可回收的对象进行清理，而是让所有存活的对象往内存的一段移动，然后直接清理掉边界以外的内存；

### 分代收集算法

主要就是根据内存中对象存活周期的不同将内存划分为几块。java堆一般划分为：新生代，老年代，然后根据不同的代采用不同的算法。

新生代采用复制算法，老年代采用标记-清理算法或者标记-整理算法；

## 虚拟机在实现这些算法时随效率考量

### 枚举根节点

> Ques：jvm在做可达性分析的时候需要从GC Root开始找到引用链，一般哪些区域可作为GC Roots？

可达性分析的一致性原则：GC停顿

在做可达性分析的时候，为了保证在分析的过程中对象的引用关系不会发生变化，此时需要将所有运行的线程都停止掉。

### 准确式GC

就是说jvm在枚举根节点的时候不需要一个不漏的检查完所有的执行上下文和全局的引用位置，虚拟机通过OopMap数据结构来记录哪些地方存放着对象的引用。

> HotSpot在类加载完成的时候就把对象内什么位置上是什么类型的数据计算出来，在JIT编译过程中也会在特定的位置记录下栈和寄存器哪些位置是引用。这样，GC在扫描的时候就直接得知这些信息了；

### 安全点

问题：因为设计中会有很多的指令会导致引用关系的关系，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间；

HotSpot的实现：hotspot并没有为每一条指令都是生成对应的OopMap，只是在“特定的位置”记录了信息，这些位置成为安全点，程序执行时只有在安全点时才会停下来执行GC；

实现这种中断的两种方法：

抢断式中断：

主动式中断：

设置一个标志位，各个线程会主动的去轮训这个标志位，发现中断标志位为真时就自己挂起，轮训标志的地方和安全点是重合的，（貌似zzm说：同时在创建对象需要分配内存的地方也会）；

### 安全区域（safe region）

Ques：

​	安全点机制只解决了那些正在运行中的线程会在不太长的时间内就会远道可进入GC的机制，但是对于那些此时处在Sleep状态或者Blocked状态的线程，这时候就无法响应jvm的中断请求，进入安全点中断挂起。此时，安全区域就可以来解决这种问题；

安全区域：

​	安全区域指的是一段代码片段之中，引用关系不会发生改变，在这个区域中任意的开始GC都是安全的。在线程执行到安全区域的代码时，首先标识自己已经进入到了安全区域，同时jvm在发起gc时，就不用管表示自己是safe region的线程了。当线程要离开safe region时，他要检查系统的是否已经完成了根节点枚举(或者整个GC过程)，如果完成了，那线程继续执行，否则就必须等待知道收到可以离开safe region的信号位置；



## 内存分配与回收策略

1. 对象优先在Eden分配

zzm书中提到的几个概念：

Minor GC（新生代GC）指发生在新生代的垃圾收集动作，因为java对象大多都是很快消亡的，所以Minor GC 是非常频繁，一般回收的速度也比较快；

Full GC / Major GC（老年代GC）指发生在老年代的GC，出现了Major GC，经常会伴随着至少一次的Minor GC（也不是绝对的）， Major GC 一般会比Minor GC慢至少10倍以上；

2. 大对象直接进入老年代

虚拟机提供了一个`-XX:PretenureSizeThreshold`参数，超过这个参数限定的对象会被分配在老年代中，这样做的目的是避免在Eden区和两个Survivor区域中发生大量的内存复制；

3. 长期存活的对象将进入老年代

虚拟机对每一个都想都会定一个对象年龄（Age）计数器。

首先对象在Eden出生并经过第一次Minor GC后仍然存活，并且Survivor区能够容纳的话，对象将会被移动到Survivor区中，并且对象年龄设为1，对象在Survivor区中没“熬过”一次Minor GC，年龄就增加1，当他的年龄增加到一定程度之后（默认是15岁），就会被晋升到老年代中。这个年龄阈值可以通过`-XX:MaxTenuringThreshold`来设置；

4. 动态年龄判断

对于3. 中描述的对象年龄超过阈值后晋升到老年代的规则并不是一定要满足的。如果Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold设定的阈值；

5. 空间担保

在JDK6之前

​	在发生Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么MinorGC可以确保是安全。如果不成立，则虚拟机会查看`HandlePromotionFailure`设置是否允许担保失败。如果允许，那么会继续检查历次老年代中最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试着进行一次Minor GC，尽管这次GC是有风险的；如果小于，或这`HandlePromotionFailure`设置不允许冒险，那这是则要进行一个Full GC；

在JDK6之后：

​	只要老年代中连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则就是Full GC；

