# Java GC 读书笔记

1. 在代码调试的时候打印系统的GC日志

```wiki
-XX:+PrintGC 输出GC日志
-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log 日志文件的输出路径
```

```wiki
-XX:+PrintGCDetails -Xloggc:../logs/gc.log -XX:+PrintGCTimeStamps  
```

### 常用的垃圾回收算法

1. 给每一个对对象都增加一个引用计数器，每当有一个地方引用这个对象时，引用计数器就加1，当应用失效时，计数器就减1；

### java 虚拟机中使用的垃圾回收算法

可发性分析：

通过一系列的成为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，此时这些对象就是可以被回收的对象对了；

Java虚拟机可作为GC Roots的对象：

* 虚拟机栈中应用的对象；
* 方法区中静态属性引用的对象；
* 方法区中常量引用的对象；
* 本地方法栈中引用的对象；

### 引用的四种分类

1. 强应用

> 强应用是指在程序代码中普遍存在的那种类似于Object obj = new Object()这种引用，只要强引用存在，垃圾回收器就永远不会回收掉被引用的对象；

2. 软引用

> 软引用用来描述一些还有用但是并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出的异常；

3. 弱引用

> 弱引用也是用来描述非必须对象的，被弱引用关联的对象只能生存到下一次垃圾回收发生之前，当垃圾回收时，无论当前内存是否足够，都会回收掉被弱引用关联的对象；

4. 虚引用

> 也称为幽灵引用和幻影引用，一个引用是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过徐引用来取得一个对象的实例。为一个对象设置虚引用的唯一目的就是能在这个对象被回收时收到一个系统通知；

### 生存还是死亡

1. 在虚拟机分析一个对象是不可大的状态时，也并不是说这个对象是“非死不可”的，这时候他暂时处于缓刑期；
2. 系统真的要回收一个对象一般要经历两个标记过程：如果一个对象在进行可达性分析后没有与GC roots相连接的引用链，那他们将会被第一次标记并且运行一次筛选，筛选的条件是此对象是否有必要要执行finalize方法。如果一个对象没有被finalize方法覆盖或者finalize方法已经被虚拟机调用过，那么虚拟机就会分析得出此对象没有必要在执行finalize方法了
3. 对于虚拟机分析得出的需要执行finalize()方法的对象，会将此对象放入一个叫F-queue的队列中，并在稍后虚拟机会创建一个低优先级的finalize线程去执行这个finalize方法(但并不承诺会等待他运行完成)
4. finalize()方法是该对象逃离被回收的最后一次机会；随后GC会对F-queue中的对象爱你进行第二次小规模标记，如果对象要在finalize()中成功拯救自己，只要重新与某个引用链接上(如何链接？)
5. 如果第二次标记后该对象还没偶逃脱，那么这个对象基本上就真的被回收了；

