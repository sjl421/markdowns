# 回溯算法的设计过程

> 该文东是自己在学习Coursera 上清华大学Wanling Qu教授的算法视频时候的笔记,

###回溯算法的使用条件

多米诺性质;



### 回溯算法的设计步骤

1. 定义解向量和每个分向量的取值范围,解向量为<x1,x2,...xn>

   确定xi的取值集合为Xi, i=1,2,...n(ps:这里的Xi都是最原始的解的集合,在随后求解过程的进行,每一维解得具体范围又会做相应的收缩)

2. 计算出在<x1,x2,...xk-1>都确定的前提下xk的取值集合Sk, 此时 Sk属于Xk,

3. 确定节点儿子的排列规则,即Sk中的解的排列顺序;

4. 判断是否满足多米诺性质;

5. 确定每个节点分支的约束条件;

   如果满足约束条件,则继续进行前行寻找下一维的解,如果不满足,就想父节点回溯;

6. 确定搜索策略:深度优先,宽度优先等;

7. 确定存储搜索路径的数据结构(一般一个数据或者链表就可以做到)

> ps:感觉课程中提到的这些规则都太教条,没有网上很多博客中总结的简单实用

---

ps: 这里写下自己在学习的过程中和参考网上的一些博客时总结下来的对回溯算法的理解;

# 回溯算法

在看博客的时候有一句话我觉得说的非常好:回溯算法的本质是穷举,但是回溯算法提供了一种可以通过的穷举达到获得问题解的方法;

### 概念

回溯算法实际类似枚举(穷举)的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现不满足条件的时候，就回溯返回，尝试别的路径。

百度解释：**回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。**

###思想

在包含问题的所有解的解空间树中，按照**深度优先搜索的策略**，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。

​       若用回溯法求问题的所有解时，要**回溯到根**，且根结点的所有可行的子树都要已被搜索遍才结束。

​       而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。



### 算法框架

####问题框架(以N皇后问题为例)

1. 求解的问题是什么样子的? 

   我们需要理解问题是什么,问题需要我们做什么,得到什么? 以N皇后问题为了, 需要我们在NxN的棋盘上放置N个皇后,然后同行,同列,对角线上都不能同时出现两个皇后,否则会攻击对方;

2. 问题的解是什么样子的? 

   其实理解了第一个问题第个人问题就自然而然的也就理解了,我们需要找到满足条件的皇后的放法,我们需要用一直能用语言来描述的数据结构来表示解,N皇后问题的解可以用开一个长度为N的数组A来放置,其中A[i]表示棋盘上第i行皇后防止的位置;

   用更学术点的方式表示就是这个解是一个N维的向量<a1,a2,...an>

3. 问题的输入的是什么样子的? 

   N皇后问题的输入是一个NxN的棋盘,和上面已经布局好的棋子,最开是棋盘是空的,但是随着问题的求解,棋盘上就有了某些已经求的某个解的部分信息,

   每一次的迭代的过程就是将已得知的解的部分作为新的已知条件,将这些已知的解得条件更新到棋盘上后得到新的问题的输入,再去求解其余的未知的解的部分;

4. 解得约束条件

   在验证解是否是满足条件时,我们需要构造出解的约束条件,只有最终解得约束条件满足,这个解才是合法的解;

5. 确定在求解的过程中解的子集可选的集合的约束条件

   以N皇后为例,我们是从i=1 -> n 依次求的a[i]的值的,假如我们已经知道了a[1-k]的取值,在求解i[k+1]的取值时就可能根据解的子集的约束条件来确定a[k+1]的可选集合,如果集合为空,说明解的前k维取a[1-k]时,没有什么a[k+1...N]的取值能是使得最终的解满足约束条件(该分支的子树为空,停止对该节点的继续搜索,开始回溯到父节点继续对父节点进行搜索),

   这里特别说明的一点是,在求解第i维可能的解时,我们得到的满足条件的第i维的解有多个可选值,此时我们需要遍历这些所有的可能的值,然后求解在分别在这些值下的可能的第 i+1, i+2,...直到n的解;

   如果发现已经遍历得到了问题的一个解(说明此时已经到了叶子节点),此时也开始回溯到父节点(n-1)开始继续回溯寻找其他的可能的解;

   > **这是回溯关键的一步**
   >
   > 对5 的编码时的特殊说明: 
   >
   > 由于搜索是一个尝试-验证的过程,为题的求解过程逐步的深入,在遍历x[k+1]的解集合时,先把x[k+1]赋一个可行的值,然后更新问题的输入继续搜索子树,在子树搜索的过程中可能找到最终满足约束条件的解也可能找不到最终满足条件的解, 此时都需要回溯到x[k+1],对解集合中的其他的可能的x[k+1]值进行尝试;
   >
   > 此时就需要我们复位x[k+1]的值和问题的输入,然后赋予x[k+1]新的值,并得到新的问题的输入,继续搜索子树;
   >
   > (如果问题是只要求的一个可能的解,那么再找到一个可行的解时程序就可以停止了,就不需要在进行回溯了)

一下给出一个go的例子,寻找N皇后所有的可行解:

```go
package eightqueen

import (
	"fmt"
)

var all = 0

func eightQueen(dimension int) {
	chess := genChess(dimension)
	place(chess, 0)
}

func genChess(dimension int) [][]int {
	chess := make([][]int, dimension)
	for i := range chess {
		chess[i] = make([]int, dimension)
	}
	return chess
}
//回溯的主题
func place(a [][]int, row int) {
	if row == len(a)-1 {			//已经递归到了棋盘最后一行,也就是搜索到了叶子节点了;
		rowData := findCol(a, row)	//确定第row行可能的解
		for i := 0; i < len(rowData); i++ {	//遍历第row行可能的解
			//set col data and print
			if rowData[i] != 0 {		//找打了最终可行的解
				a[row][i] = rowData[i]	//将最后一行的棋子放到,得到最终的解
				print(a)				//将结果输出
				//reset the row data	//将上一次的条件复位,还原问题,继续的达到下一个可行的解
				a[row][i] = 0			
			}
		}
		return
	} else {							//还没有到最后一行
		rowData := findCol(a, row)		//确定第row行可能的解
		for i := 0; i < len(rowData); i++ { //遍历第row行可能的解
			if rowData[i] != 0 {
				a[row][i] = rowData[i]	//将第row行赋予一个可行的解
              place(a, row+1)			//继续递归搜索子树(剩余的需要确定的解)
				a[row][i] = 0			//将上一次的条件复位,还原问题,继续的达到下一个可行的解
			}
		}
	}
}

func findCol(a [][]int, row int) []int {	//确定子问题解空间
	result := make([]int, len(a))
	for i := 0; i < len(a); i ++ {
		if isColOk(a, row, i) && isDiaOk(a, row, i) {
			result[i] = 1
		}
	}
	return result
}

func isColOk(a [][]int, row int, col int) bool {
	for i := 0; i < row; i++ {
		if a[i][col] != 0 {
			return false
		}
	}
	return true
}

func isDiaOk(a [][]int, row int, col int) bool {
	for i, j := row-1, col-1; i >= 0 && j >= 0; {
		if a[i][j] != 0 {
			return false
		}
		i--
		j--
	}
	for i, j := row-1, col+1; i >= 0 && j >= 0 && j < len(a); {
		if a[i][j] != 0 {
			return false
		}
		i--
		j++
	}
	return true
}

func print(a [][]int) {
	fmt.Println("=======================", all)
	/*	for row := range a {
			fmt.Println(row)
		}*/
	for i := 0; i < len(a); i ++ {
		fmt.Println(a[i])
	}
	fmt.Println("========================")
	all++
}
```

在求解回溯问题的时候还可以上使用非递归的方式来求解:

算法的框架如下:

先规定，a[i] = j的数列中，下标i是行，数列所对应的值j是列。

```c
1: int a[n],i;
2: 初始化数组a[];
3: i = 1;
4: while (i>0(有路可走)   and  (未达到目标))  // 还未回溯到头
5: {
6:     if(i > n)                                              // 搜索到叶结点
7:     {   
8:           搜索到一个解，输出；
9:     }
10:     else                                                   // 处理第i个元素
11:     { 
12:           a[i]第一个可能的值；
13:           while(a[i]在不满足约束条件且在搜索空间内)
14:           {
15:               a[i]下一个可能的值；
16:           }
17:           if(a[i]在搜索空间内)
18:          {
19:               标识占用的资源；
20:               i = i+1;                              // 扩展下一个结点
21:          }
22:          else 
23:         {
24:               清理所占的状态空间；            // 回溯
25:               i = i –1; 
26:          }
27: }
```

针对八皇后问题的飞递归解法(C语言)

```c
int queen( int n ){
	int	count = 0;
	int	a[MaxSize];
	InitQ( a, n );
	int i = 0; /* 从第一行开始 */
	while ( 1 )	{
		if ( a[i] < n )	{
			if ( is_conflict( a, i ) ){
				a[i]++;
				continue;
			}	
			if ( i >= n - 1 ) {
				count++;
				Print_Queen( a, n );    /* 输出可行的棋盘 */
				a[n - 1]++;             /* 并且考虑此行的下一列是否可以 */
				continue;
			} /* 以上部分会测试完每一行 */
			i++;                            /* 没有冲突 尝试下一行 */
			continue;
		} else{                                 /* 如果i一直加  则最后 */
			a[i] = 0;                       /* 将列复原 */
			i--;                            /* 行返回 */
			if ( i < 0 ) {
				return(count);          /* 如果不能再回退了说明全部情况都已经考虑完了 */
			}
			a[i]++;
			continue;
		}
	}
}
```

