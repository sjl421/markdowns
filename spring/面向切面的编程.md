# 面向切面的编程

```
最近在学这方面的内容，读到的这段话我感觉说的很清楚了：这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。      但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。    也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。       一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。      AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充
```

附上网址：[JavaWeb过滤器.监听器.拦截器](https://link.zhihu.com/?target=http%3A//hejiajunsh.iteye.com/blog/1776569)

**Q1：面向切面编程（AOP）解决什么问题？** 
**A1：**把**横切关注点**与**业务逻辑**相分离。

**Q2：什么是横切关注点？** 
**A2：**在软件开发中，**散布于应用中多处的功能**。

**日志**是**应用切面**的常见范例，但并不是切面适用的唯一场景。

**DI** 有助于**应用对象**之间的解耦，而 **AOP** 可以实现**横切关注点与它们所影响的对象**之间的解耦。

![这里写图片描述](http://img.blog.csdn.net/20170805144750819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlueURvbHBoaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 
上图展示了一个被划分为模块的典型应用。每个模块的核心功能都是为特定业务领域提供服务，但是这些模块都需要类似的**辅助功能**，例如安全和事务管理。

如果要**重用通用功能**的话，最常见的面向对象技术是**继承**或**委托**。

**Q1：为什么要使用切面来取代继承和委托？** 
**A1：**如果在整个应用中都使用相的基类，**继承**往往会导致一个**脆弱的对象体系**；而使用**委托**可能需要对委托对象进行**复杂的调用**。而使用**面向切面编程**时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。

**Q2：什么是切面？** 
**A2：\***横切关注点被模块化为特殊的类*，这些类被称为切面。

**Q3：使用面向切面编程的好处？** 
**A3：**①、现在每个关注点都集中于一个地方，而不是分散到多处代码中；②、服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。

#### **Q：AOP 术语有哪些？**

**A：**描述切面的常用术语有通知（advice）、切点（pointcut）和连接点（join point）。

**&通知（Advice）**

在 AOP 术语中，切面的工作被成为通知。

Spring 切面可以应用 5 种类型的通知：

- ①、**前置通知（Before）**：在目标方法被调用之前调用通知功能；
- ②、**后置通知（After）**：在目标方法完成之后通用通知，此时不会关心方法的输出是什么；
- ③、**返回通知（After-returning）**：在目标方法成功执行之后调用通知；
- ④、**异常通知（After-throwing）**：在目标方法抛出异常后调用通知；
- ⑤、**环绕通知（Around）**：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。

**&连接点（Join point）**

我们的应用可能也有数以千计的时机应用通知。这些**时机**被称为**连接点**。连接点是**在应用执行过程中能够插入切面**的一个点。这个点可以是**调用方法时**、**抛出异常时**、**甚至修改一个字段**。**切面代码**可以利用这些点**插入到应用的正常流程之中**，并**添加新的行为**。

**&切点（Pointcut）**

一个切面并不需要通知应用的所有连接点。**切点**有助于**缩小切面所通知的连接点的范围**。 **切点的定义**会匹配通知所要织入的**一个或多个连接点**。我们通常使用明确的**类**和**方法名称**，或是利用**正则表达式**定义所匹配的的**类**和**方法名称**来指定这些切点。

**&切面（Aspect）**

切面是**通知和切点的结合**。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。

**&引入（Introduction）**

引入**允许我们向现有的类添加新方法或属性**。

**&织入（Weaving）**

织入是**把切面应用到目标对象**并**创建新的代理对象**的过程。切面在**指定的连接点**被织入到**目标对象**中。在目标对象的生命周期里有多个点可以进行织入：

- 编译期：切面在**目标类编译时**织入。这种方式需要**特殊的编译器**。AspectJ 的织入编译器就是以这种方法织入切面的。
- 类加载期：切面在**目标类加载到 JVM 时**被织入。这种方式需要**特殊的类加载器**，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5 的加载时织入就是支持以这种方式织入切面。
- 运行期：切面在**应用运行的某个时刻**被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个**代理对象**。Spring AOP 就是以这种方式织入切面的。

现在我们已经了解了如下知识：**通知包含了需要用于多个应用对象的横切行为**；**连接点是程序执行过程中能够应用通知的所有点**；**切点定义了通知被应用的具体位置（在哪些连接点）**。**关键的概念是切点定义了哪些连接点会得到通知**。

#### **Q：以上 AOP 的核心概念是如何在 Spring 中实现的？**

**AOP 框架的基本功能**：创建切点来定义切面所织入的连接点。

**Q1：Spring 提供了哪几种类型的 AOP 支持？** 
**A1：**提供了以下四种类型：

- **基于代理的经典 Spring AOP**；
- **纯 POJO 切面**；
- **@AspectJ 注解驱动的切面**；
- **注入式 AspectJ 切面（适用于 Spring 各版本）**。

前三种都是 Spring AOP 实现的变体，Spring AOP 构建在动态代理基础之上，因此，**Spring 对 AOP 的支持局限于方法拦截**。

借助 Spring 的 **aop 命名空间**，我们可以**将纯 POJO 转换为切面**。实际上，这些 POJO 只是提供了满足切点条件时所要调用的方法。但是**需要 XML 配置**。

Spring 借鉴了 **AspectJ 的切面**，以**提供注解驱动的 AOP**。本质上，它依然是 Spring 基于代理的 AOP，但是编程模型几乎与编写成熟的 AspectJ 注解切面完全一致。这种 AOP 风格的好处在于能够**不使用 XML 来完成功能**。

如果你的 AOP 需求超过了简单的方法调用（如**构造器**或**属性拦截**），那么你需要考虑使用 **AspectJ 来实现切面**。这种情况下，上文所示的第四种类型能够帮助你将值注入到 AspectJ 驱动的切面中。

**Q2：Spring AOP 框架有一些什么关键知识？** 
**A2：** 
①、**Spring 通知是 Java 编写的**：我们可以使用与普通 Java 开发一样的集成开发环境（IDE）来开发切面。而且，定义通知所应用的切点通常会使用**注解**或在 **Spring 配置文件里采用 XML** 来编写。 
②、**Spring 在运行时通知对象**：通过在代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。**代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标 bean**。**当代理拦截到方法调用时，在调用目标 bean 方法之前，会执行切面逻辑**。直到**应用需要被代理的 bean** 时，Spring 才**创建代理对象**。因为 Spring 运行时才创建代理对象，所以我们不需要特殊的编译器来织入 Spring AOP 的切面。 
③、Spring 只支持方法级别的连接点：因为 Spring 基于动态代理，所以 Spring **只支持方法连接点**。然而 **AspectJ** 和 **JBoss** 还支持**字段**和**构造器**接入点。

Spring **缺少对字段连接点的支持**，**无法让我们创建细粒度的通知**，例如**拦截对象字段的修改**。 
而且**不支持构造器连接点**，我们就**无法在 bean 创建时应用通知**。

但是方法拦截可以满足绝大部分的需求，如果**需要方法拦截之外的连接点拦截功能**，那么我们可以利用 **AspectJ 来补充 Spring AOP 的功能**。

(原文地址：http://blog.csdn.net/tinydolphin/article/details/76719860)

