#网桥

* 网桥是工作数据链路层的(第二层)
* 提高局域网效率,减少广播风暴的出现

### 介绍

​	Linux可以支持多个不同的网络, 他们之间能够通信,linux通过网桥来将这些网络连接起来并实现各网络主机之间的相互通信.

​	网桥是一个二层的虚拟设备,把若干个网络接口"连接"起来,以使得网口之间的报文能够相互转发(二层网络的中数据的转发是通过保重的MAC地址信息来转发, 其中不设计ip地址的解析,ip地址的解析是在上一层) . 网桥能够解析收发的报文,读取目标MAC地址的信息,和自己记录的MAC表结合,来决策报文的转发目标网口, 这些是通过网桥的`MAC地址学习` 是来实现的. 

​	在网桥转发报文时,网桥只需要向特定的网口进行转发,从而避免必须要的网络交互, 如果网桥遇到一个自己从未学习到的地址, 就无法知道这个报文应该向哪个网口转发,就将报文广播为所有的网口(报文的来源网口除外);

​	在实际网络中,网络的拓扑结构不是永久不变的,如果设备移动到另一个端口上,而他没有发送任何数据, 那么网桥设备就无法感知这个变化,结果网桥还是想原来的端口转发数据包,在这种情况写数据就会丢失. 所以网桥还要对学习到的MAC地址表加上超时时间(默认5min), 如果网桥收到了对应端口MAC地址会发的包,则重置超时时间,否则超过了超时时间后,就认为那个设备已经不在那个端口上了,他就会重新广播发送.

### 网桥的工作原理

​	从某个方面来讲,网桥的功能和交换机的功能是十分相似的,下面从一个帖子中的内容来理解一下**桥接**的概念.

####桥接的概念

(原文地址:http://blog.csdn.net/bailyzheng/article/details/29244963)

简单来说，桥接就是把一台机器上的若干个网络接口“连接”起来。其结果是，其中一个网口收到的报文会被复制给其他网口并发送出去。以使得网口之间的报文能够互相转发。

交换机就是这样一个设备，它有若干个网口，并且这些网口是桥接起来的。于是，与交换机相连的若干主机就能够通过交换机的报文转发而互相通信。

如下图：主机A发送的报文被送到交换机S1的eth0口，由于eth0与eth1、eth2桥接在一起，故而报文被复制到eth1和eth2，并且发送出 去，然后被主机B和交换机S2接收到。而S2又会将报文转发给主机C、D。

[![img](http://blog.chinaunix.net/photo/109828_100908155439.jpg)](http://blog.chinaunix.net/photo/109828_100908155439.jpg)

交换机在报文转发的过程中并不会篡改报文数据，只是做原样复制。然而桥接却并不是在物理层实现的，而是在数据链路层。交换机能够理解数据链路层的报文，所 以实际上桥接却又不是单纯的报文转发。

交换机会关心填写在报文的数据链路层头部中的Mac地址信息（包括源地址和目的地址），以便了解每个Mac地址所代表的主机都在什么位置（与本交换机的哪 个网口相连）。在报文转发时，交换机就只需要向特定的网口转发即可，从而避免不必要的网络交互。这个就是交换机的“地址学习”。但是如果交换机遇到一个自 己未学习到的地址，就不会知道这个报文应该从哪个网口转发，则只好将报文转发给所有网口（接收报文的那个网口除外）。

比如主机C向主机A发送一个报文，报文来到了交换机S1的eth2网口上。假设S1刚刚启动，还没有学习到任何地址，则它会将报文转发给eth0和 eth1。同时，S1会根据报文的源Mac地址，记录下“主机C是通过eth2网口接入的”。于是当主机A向C发送报文时，S1只需要将报文转发到 eth2网口即可。而当主机D向C发送报文时，假设交换机S2将报文转发到了S1的eth2网口（实际上S2也多半会因为地址学习而不这么做），则S1会 直接将报文丢弃而不做转发（因为主机C就是从eth2接入的）。

然而，网络拓扑不可能是永不改变的。假设我们将主机B和主机C换个位置，当主机C发出报文时（不管发给谁），交换机S1的eth1口收到报文，于是交换机 S1会更新其学习到的地址，将原来的“主机C是通过eth2网口接入的”改为“主机C是通过eth1网口接入的”。

但是如果主机C一直不发送报文呢？S1将一直认为“主机C是通过eth2网口接入的”，于是将其他主机发送给C的报文都从eth2转发出去，结果报文就发 丢了。所以交换机的地址学习需要有超时策略。对于交换机S1来说，如果距离最后一次收到主机C的报文已经过去一定时间了（默认为5分钟），则S1需要忘记 “主机C是通过eth2网口接入的”这件事情。这样一来，发往主机C的报文又会被转发到所有网口上去，而其中从eth1转发出去的报文将被主机C收到。

### 网桥和交换机的区别

1. 最简单的网桥只有2个端口，每个端口连接一个Lan，复杂一些的网桥可以有多个端口。交换机是更先进的网桥，有多个端口。
2. MAC映射表不（CAM）一样。网桥的映射表是一对多的，交换机的是一对一的。
3. 两个网络桥接时所要处理的数据量会比一般交换机需要处理的量要大，所以网桥的缓存一般会比交换机要大。

**Linux网桥跟交换机的区别**

1. 交换机是一个二层设备
2. 而linux上的网桥除了完成交换机的二层功能外，还可以把数据提交上上层协议栈

Linux内核置支持网口的桥接,但是与单纯的交换机不同,交换机只是一个二层设备,对于接受到的报文,要么转发,要么丢弃.运行linux内核的机器本身就是一台主机,有可能是网络报文的目的地,其受到的报文除了转发和丢弃,还可能被送到网络协议栈的上层(网络层), 从而被自己(这台主机本身的协议栈)消化, 所以我们既可以把网桥看作一个二层设备,也可以看作一个三层设备.

###Linux的桥接实现

网桥设备br0绑定了eth0和eth1。对于网络协议栈的上层来说，只看得到br0，因为桥接是在数据链路层实现的，上层不需要关心桥接的细节。于是协 议栈上层需要发送的报文被送到br0，网桥设备的处理代码再来判断报文该被转发到eth0或是eth1，或者两者皆是；反过来，从eth0或从eth1接 收到的报文被提交给网桥的处理代码，在这里会判断报文该转发、丢弃、或提交到协议栈上层。
而有时候eth0、eth1也可能会作为报文的源地址或目的地址，直接参与报文的发送与接收（从而绕过网桥）

![img](http://blog.chinaunix.net/photo/109828_100908155447.jpg)

linux内核支持网口的桥接（目前只支持以太网接口）。但是与单纯的交换机不同，交换机只是一个二层设备，对于接收到的报文，要么转发、要么丢弃。小型 的交换机里面只需要一块交换芯片即可，并不需要CPU。而运行着linux内核的机器本身就是一台主机，有可能就是网络报文的目的地。其收到的报文除了转 发和丢弃，还可能被送到网络协议栈的上层（网络层），从而被自己消化。

linux内核是通过一个虚拟的网桥设备来实现桥接的。这个虚拟设备可以绑定若干个以太网接口设备，从而将它们桥接起来。如上图（摘自ULNI）：

参考:http://blog.csdn.net/bailyzheng/article/details/29244963

TODO

http://blog.csdn.net/u013485792/article/details/51493136

##veth

中有提到过，每一个VETH网卡都是一对儿以太网卡，除了xmit接口与常规的以太网卡驱动不同之外，其它的几乎就是一块标准的以太网卡。VETH网卡既然是一对儿两个，那么我们把一块称作另一块的peer，标准上也是这么讲的。其xmit的实现就是：将数据发送到其peer，触发其peer的RX。可以把 `veth pair` 当做是双向的 pipe（管道），从一个方向发送的网络数据，可以直接被另外一端接收到；或者也可以想象成两个 namespace 直接通过一个特殊的虚拟网卡连接起来，可以直接通信。

那么问题来了，这些数据如何发送到VETH网卡对儿之外呢？自问必有自答，自答如下：

**1.如果确实需要将数据发到外部，通过将一块VETH网卡和一块普通ETHx网卡进行bridge，通过bridge逻辑将数据forward到ETHx，进而发出；**

**2.难道非要把数据包发往外部吗？类似loopback那样的，不就是自发自收吗？使用VETH可以很方面并且隐秘地将数据包从一个net namespace发送到同一台机器的另一个net namespace，并且不被嗅探到。**

​       VETH虚拟网卡非常之简单，原理图如下所示：

![img](http://img.blog.csdn.net/20150517134821346?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZG9nMjUw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

参考资料:http://cizixs.com/2017/02/10/network-virtualization-network-namespace